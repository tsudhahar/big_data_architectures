# big_data_architectures# SMACK## The SMACK stack “mentions” Spark, Mesos, Akka, Cassandra, and Kafka. We’ll talk about the elements here in more detail later, but notice a few are the same from the Hadoopdiagram, including HDFS, Spark, and YARN.The major components are 1) storage (Kafka, for durability and temp. storage of inflight data, HDFS, databases, and Elastic Search), 2) streaming compute engines (Akka, Spark, and Flink, plus many more not shown), and 3) a resource manager& scheduling system (YARN, as before, but also Mesos and cloud services)# Microservices## Microservices try to do one thing and do it well. They must manage their own data, because a shared data store is a monolith in disguise.## It’s also common to provide a uniform API abstraction to clients which hides the independent APIs of the underlying sources and also provides a level of indirection, so it’s easier to swap out instances of these services## They might be smaller in memory and CPU footnote, but only as a side efect of their focus on doing one thing. They communicate with each other through messages and should be asynchronous to maximize throughput, although this isn’talways best. Because they do one thing and have a very clear boundary and interfaces to other services, it’s easy to organize their development into teams, essentially a Reverse Conway’s Law. This makes it easier to evolve and deploy themindependently of other microservices, too. Very smaller “dockerized” services might last just a few minutes, but could run a very long time. A big drawback of microservices is the longer communication latency of calls between them comparedto function calls in the same process